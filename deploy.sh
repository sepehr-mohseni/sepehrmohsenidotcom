#!/bin/bash
set -e

# ===========================================
# Portfolio Deployment Script
# ===========================================
# Usage: ./deploy.sh [command]
# Commands:
#   setup       - First-time setup (creates config, starts with SSL)
#   deploy      - Full deployment (pull, fresh build, up, verify)
#   up          - Start containers (dev mode, no SSL)
#   up-prod     - Start with Traefik (production, auto SSL)
#   down        - Stop containers
#   restart     - Restart containers
#   logs        - View logs
#   status      - Check status
#   verify      - Verify deployment (Prisma, DB, health)
#   db          - Start DB web UI (accessible via SSH tunnel)
#   backup      - Backup database
#   restore     - Restore database from backup
#   build-fresh - Clean cache and build fresh
#   clean       - Remove unused Docker resources
#   ssl-status  - Check SSL certificate status
# ===========================================

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
APP_NAME="portfolio"
REPO_URL="https://github.com/sepehr-mohseni/sepehrmohsenidotcom.git"
BACKUP_DIR="./backups"
DATA_VOLUME="portfolio_portfolio-data"
ENV_FILE=".env.production"

# Helper functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if .env.production exists
check_env() {
    if [ ! -f "$ENV_FILE" ]; then
        log_warn "$ENV_FILE not found."
        return 1
    fi
    return 0
}

# First-time setup
first_time_setup() {
    log_info "ðŸš€ First-time setup..."
    echo ""
    
    # Check if already configured
    if [ -f "$ENV_FILE" ]; then
        log_warn "$ENV_FILE already exists."
        read -p "Overwrite? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Setup cancelled. Run './deploy.sh up-prod' to start."
            exit 0
        fi
    fi
    
    # Get domain
    read -p "Enter your domain (e.g., sepehrmohseni.com): " DOMAIN
    if [ -z "$DOMAIN" ]; then
        log_error "Domain is required"
        exit 1
    fi
    
    # Get email for SSL
    read -p "Enter email for SSL certificates (Let's Encrypt): " ACME_EMAIL
    if [ -z "$ACME_EMAIL" ]; then
        log_error "Email is required for SSL"
        exit 1
    fi
    
    # Get database name
    read -p "Enter database name (default: portfolio): " DB_NAME
    DB_NAME=${DB_NAME:-portfolio}
    
    # Create .env.production
    cat > "$ENV_FILE" << EOF
# ===========================================
# Production Configuration
# Generated by setup script - DO NOT COMMIT
# ===========================================

# Domain
DOMAIN=$DOMAIN
NEXT_PUBLIC_SITE_URL=https://$DOMAIN

# SSL Certificate Email
ACME_EMAIL=$ACME_EMAIL

# Database
DB_NAME=$DB_NAME

# Ports
APP_PORT=3000
DB_UI_PORT=8080
EOF

    log_success "Configuration saved to $ENV_FILE"
    echo ""
    
    # Build and start
    log_info "Building application..."
    docker compose --env-file "$ENV_FILE" build
    
    log_info "Starting with Traefik (auto SSL)..."
    docker compose --env-file "$ENV_FILE" --profile production up -d
    
    echo ""
    log_success "ðŸŽ‰ Setup complete!"
    echo ""
    log_info "Your site will be available at: https://$DOMAIN"
    log_info "SSL certificate will be automatically obtained from Let's Encrypt."
    log_warn "Note: DNS must point to this server for SSL to work."
    echo ""
    log_info "Useful commands:"
    echo "  ./deploy.sh logs      - View logs"
    echo "  ./deploy.sh status    - Check status"
    echo "  ./deploy.sh ssl-status - Check SSL certificate"
    echo "  ./deploy.sh backup    - Backup database"
}

# Pull latest code from git
pull_code() {
    log_info "Pulling latest code from git..."
    git fetch origin
    git reset --hard origin/main
    log_success "Code updated"
}

# Build Docker images
build_images() {
    log_info "Building Docker images..."
    docker compose --env-file "$ENV_FILE" build --no-cache
    log_success "Images built"
}

# Full clean build (remove all cache)
clean_build() {
    log_info "ðŸ§¹ Cleaning all Docker build cache..."
    docker builder prune -af 2>/dev/null || true
    
    log_info "ðŸ”¨ Building fresh (no cache)..."
    docker compose --env-file "$ENV_FILE" build --no-cache --pull
    log_success "Fresh build complete"
}

# Verify deployment (check Prisma, DB, health)
verify_deployment() {
    echo ""
    log_info "ðŸ” Verifying deployment..."
    echo ""
    
    # Check container is running
    if ! docker ps --format '{{.Names}}' | grep -q "portfolio-app"; then
        log_error "Container portfolio-app is not running"
        return 1
    fi
    log_success "Container is running"
    
    # Check health status
    HEALTH=$(docker inspect --format='{{.State.Health.Status}}' portfolio-app 2>/dev/null || echo "unknown")
    if [ "$HEALTH" = "healthy" ]; then
        log_success "Container is healthy"
    else
        log_warn "Container health: $HEALTH"
    fi
    
    # Check Prisma CLI exists
    log_info "Checking Prisma CLI..."
    if docker exec portfolio-app test -f ./node_modules/.bin/prisma; then
        log_success "Prisma CLI found"
        
        # Check Prisma version
        PRISMA_VER=$(docker exec portfolio-app ./node_modules/.bin/prisma --version 2>&1 | head -1 || echo "unknown")
        log_info "Prisma version: $PRISMA_VER"
    else
        log_error "Prisma CLI not found in container"
    fi
    
    # Check database tables
    log_info "Checking database tables..."
    if docker exec portfolio-app ./node_modules/.bin/prisma db push --skip-generate 2>&1 | grep -q "already in sync"; then
        log_success "Database schema is in sync"
    else
        log_warn "Running schema push..."
        docker exec portfolio-app ./node_modules/.bin/prisma db push --skip-generate
    fi
    
    # Check if tables exist by querying
    log_info "Verifying tables exist..."
    source "$ENV_FILE"
    DB_NAME=${DB_NAME:-portfolio}
    TABLE_COUNT=$(docker exec portfolio-app sqlite3 /app/data/${DB_NAME}.db ".tables" 2>/dev/null | wc -w || echo "0")
    if [ "$TABLE_COUNT" -gt 0 ]; then
        log_success "Database has $TABLE_COUNT tables"
        docker exec portfolio-app sqlite3 /app/data/${DB_NAME}.db ".tables" 2>/dev/null || true
    else
        log_warn "No tables found - database may need initialization"
    fi
    
    # Check HTTP response
    log_info "Checking HTTP response..."
    HTTP_CODE=$(docker exec portfolio-app wget -q -O /dev/null -S http://127.0.0.1:3000/ 2>&1 | grep "HTTP/" | tail -1 | awk '{print $2}' || echo "000")
    if [ "$HTTP_CODE" = "200" ]; then
        log_success "HTTP 200 OK"
    else
        log_warn "HTTP response: $HTTP_CODE"
    fi
    
    echo ""
    log_success "âœ… Verification complete"
}

# Start containers (dev mode, no SSL)
start_containers() {
    log_info "Starting containers (dev mode)..."
    docker compose --env-file "$ENV_FILE" up -d portfolio
    log_success "Containers started on port 3000"
    
    sleep 3
    check_health
}

# Start with Traefik (production mode with SSL)
start_production() {
    log_info "Starting in production mode with Traefik..."
    docker compose --env-file "$ENV_FILE" --profile production up -d
    log_success "Production stack started"
    
    sleep 5
    check_health
    
    echo ""
    log_info "SSL certificate status:"
    ssl_status
}

# Stop containers
stop_containers() {
    log_info "Stopping containers..."
    docker compose --env-file "$ENV_FILE" --profile production down
    log_success "Containers stopped"
}

# Check health
check_health() {
    if docker compose --env-file "$ENV_FILE" ps 2>/dev/null | grep -q "healthy"; then
        log_success "Application is healthy!"
    else
        log_warn "Application may still be starting. Check: ./deploy.sh logs"
    fi
}

# View logs
view_logs() {
    docker compose --env-file "$ENV_FILE" --profile production logs -f --tail=100
}

# Check status
check_status() {
    echo ""
    log_info "Container Status:"
    docker compose --env-file "$ENV_FILE" --profile production ps
    echo ""
    log_info "Resource Usage:"
    docker stats --no-stream $(docker compose --env-file "$ENV_FILE" ps -q 2>/dev/null) 2>/dev/null || true
    echo ""
    log_info "Volume Info:"
    docker volume inspect $DATA_VOLUME 2>/dev/null | grep -E "(Name|Mountpoint)" || log_warn "Volume not found"
}

# Check SSL status
ssl_status() {
    if [ -f "$ENV_FILE" ]; then
        source "$ENV_FILE"
        if [ -n "$DOMAIN" ]; then
            log_info "Checking SSL for $DOMAIN..."
            echo | openssl s_client -servername "$DOMAIN" -connect "$DOMAIN":443 2>/dev/null | openssl x509 -noout -dates 2>/dev/null || log_warn "Could not check SSL. Domain may not be accessible yet."
        else
            log_warn "DOMAIN not set in $ENV_FILE"
        fi
    else
        log_warn "$ENV_FILE not found"
    fi
}

# Start DB web UI
start_db_ui() {
    log_info "Starting SQLite Web UI..."
    log_warn "âš ï¸  For security, DB UI is only accessible from localhost."
    log_warn "Use SSH tunnel to access remotely:"
    log_warn "  ssh -L 8080:localhost:8080 user@your-server"
    log_warn "Then open: http://localhost:8080"
    echo ""
    docker compose --env-file "$ENV_FILE" --profile tools up -d sqlite-web
    log_success "DB UI started on localhost:8080"
}

# Backup database
backup_db() {
    if ! check_env; then
        log_error "Run './deploy.sh setup' first"
        exit 1
    fi
    source "$ENV_FILE"
    DB_NAME=${DB_NAME:-portfolio}
    
    mkdir -p $BACKUP_DIR
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_$TIMESTAMP.db"
    
    log_info "Creating database backup..."
    
    docker run --rm \
        -v $DATA_VOLUME:/data:ro \
        -v $(pwd)/$BACKUP_DIR:/backup \
        alpine cp /data/${DB_NAME}.db /backup/${DB_NAME}_$TIMESTAMP.db 2>/dev/null || {
            log_error "Backup failed. Is the database initialized?"
            exit 1
        }
    
    gzip "$BACKUP_FILE"
    log_success "Backup created: ${BACKUP_FILE}.gz"
    
    # Keep only last 10 backups
    ls -t $BACKUP_DIR/*.gz 2>/dev/null | tail -n +11 | xargs -r rm
    log_info "Old backups cleaned (keeping last 10)"
}

# Restore database
restore_db() {
    if ! check_env; then
        log_error "Run './deploy.sh setup' first"
        exit 1
    fi
    source "$ENV_FILE"
    DB_NAME=${DB_NAME:-portfolio}
    
    if [ -z "$2" ]; then
        log_info "Available backups:"
        ls -la $BACKUP_DIR/*.gz 2>/dev/null || log_warn "No backups found"
        echo ""
        log_warn "Usage: ./deploy.sh restore <backup_file.db.gz>"
        exit 1
    fi
    
    BACKUP_FILE="$2"
    
    if [ ! -f "$BACKUP_FILE" ]; then
        log_error "Backup file not found: $BACKUP_FILE"
        exit 1
    fi
    
    log_warn "âš ï¸  This will replace the current database!"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Stopping application..."
        docker compose --env-file "$ENV_FILE" stop portfolio
        
        log_info "Restoring database..."
        TEMP_DIR=$(mktemp -d)
        gunzip -c "$BACKUP_FILE" > "$TEMP_DIR/${DB_NAME}.db"
        
        docker run --rm \
            -v $DATA_VOLUME:/data \
            -v $TEMP_DIR:/backup:ro \
            alpine cp /backup/${DB_NAME}.db /data/${DB_NAME}.db
        
        rm -rf "$TEMP_DIR"
        
        log_info "Starting application..."
        docker compose --env-file "$ENV_FILE" start portfolio
        
        log_success "Database restored from $BACKUP_FILE"
    else
        log_info "Restore cancelled"
    fi
}

# Clean unused Docker resources
clean_docker() {
    log_info "Cleaning unused Docker resources..."
    docker system prune -f
    docker image prune -f
    log_success "Cleanup complete"
}

# Full deployment
full_deploy() {
    if ! check_env; then
        log_error "Run './deploy.sh setup' first"
        exit 1
    fi
    
    pull_code
    clean_build
    stop_containers
    start_production
    
    sleep 5
    verify_deployment
    
    echo ""
    log_success "ðŸš€ Deployment complete!"
}

# Main command handler
case "${1:-help}" in
    setup)
        first_time_setup
        ;;
    deploy)
        full_deploy
        ;;
    up)
        check_env || { log_error "Run './deploy.sh setup' first"; exit 1; }
        start_containers
        ;;
    up-prod)
        check_env || { log_error "Run './deploy.sh setup' first"; exit 1; }
        start_production
        ;;
    down)
        stop_containers
        ;;
    restart)
        check_env || exit 1
        stop_containers
        start_production
        ;;
    logs)
        view_logs
        ;;
    status)
        check_status
        ;;
    ssl-status)
        ssl_status
        ;;
    db)
        start_db_ui
        ;;
    backup)
        backup_db
        ;;
    restore)
        restore_db "$@"
        ;;
    build)
        check_env || exit 1
        build_images
        ;;
    build-fresh)
        check_env || exit 1
        clean_build
        ;;
    verify)
        check_env || exit 1
        verify_deployment
        ;;
    clean)
        clean_docker
        ;;
    *)
        echo "Portfolio Deployment Script"
        echo ""
        echo "Usage: ./deploy.sh [command]"
        echo ""
        echo "First-time setup:"
        echo "  setup       - Interactive setup (creates config, starts with auto SSL)"
        echo ""
        echo "Deployment:"
        echo "  deploy      - Full deployment (pull, build, start with SSL)"
        echo "  up          - Start containers (dev mode, port 3000)"
        echo "  up-prod     - Start with Traefik (production, auto SSL)"
        echo "  down        - Stop all containers"
        echo "  restart     - Restart containers"
        echo ""
        echo "Monitoring:"
        echo "  logs        - View logs"
        echo "  status      - Check container status"
        echo "  ssl-status  - Check SSL certificate"
        echo ""
        echo "Database:"
        echo "  db          - Start DB web UI (localhost:8080)"
        echo "  backup      - Backup database"
        echo "  restore     - Restore from backup"
        echo ""
        echo "Maintenance:"
        echo "  build       - Build images"
        echo "  build-fresh - Clean all cache and build fresh"
        echo "  verify      - Verify deployment (Prisma, DB, health)"
        echo "  clean       - Clean Docker resources"
        ;;
esac
